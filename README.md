# solve_nonogram

C/C++을 이용하여 노노그램을 완성해주는 프로그램을 만들어보려 한다.

노노그램의 재미를 알려준 침착맨에게 감사하다. 


# 어떻게 문제를 풀것인가?

## 무지성한 방법

---

각 행/열에 대하여 아래를 반복한다.

### 1. 단서를 이용하여 모든 경우의 수를 생성한다.

---

모든 칸이 비워져있다고 가정하면,

- 각 단서 사이에는 한 칸 이상을 비워야 할 것이다.
- 양 끝은 비우지 않아도 되지만 띄워질 수도 있을 것이다.
- 따라서 단서의 양 끝과 그 사이사이에는 공간이 있을 것이다.
- 행/열에 단서와 최소한의 공간을 집어넣으면 남는 공간이 있을 것이다. 이것을 ‘가동범위(`movable_padding`)’라고 하자.
- 이 가동범위를 단서의 양 끝과 그 사이사이에 나누어 넣어야 할 것이다.

---

경우의 수는 (가동범위)를 최대 (단서의 개수 + 1)개의 수로 쪼개는 경우의 수 이다.

이는 (단서의 개수 + 1 = $n$)개의 상자에서 (가동범위 = $r$)개의 같은 구슬을 나누어 넣는 경우의 수와 같다.

이를 중복조합이라고 하며, 다음과 같이 계산할 수 있다.

$$
_n\mathrm{H}_r = _{n+r-1}\mathrm{C}_{\,n-1} = \frac{(n+r-1)!}{r!\,(n-1)!}
$$

가동범위는 (단서의 총합) + (단서의 개수 - 1)개 이다.

---

이미 특정된 칸을 참고하게 되면 불가능한 경우의 수가 줄어들 것이다...

### 2. 이미 특정된 칸을 참고하여 불가능한 경우의 수를 제거한다.

- 이때 각 칸(`cell`)은 3가지 상태가 필요함을 알 수 있다 : 🔲 빈 상태, ⬛ 채워진 상태, ❎ 금지된 상태.

### 3. 남은 경우의 수에서 무조건 칠해지는 칸을 채우고, 무조건 안 칠해지는 칸을 금지한다.

## 인간다운 방법

---

각 행/열에 대하여 아래를 반복한다.

1. 각 행/열의 단서와 이미 특정된 칸을 참고하여 모든 경우의 수를 생각한다. 
    1. 이 행/열의 가동범위를 계산한다.
    2. 이미 특정된 칸을 참고한다.
    3. 모든 경우의 수를 계산한다.
2. 모든 경우의 수에서 무조건 칠해지는 칸을 채우고, 무조건 안 칠해지는 칸을 금지한다.

### 경우의 수 생각하기

---

모든 칸이 비워져있다고 가정하면,

- 각 단서 사이에는 한 칸 이상을 비워야 할 것이다.
- 양 끝은 비우지 않아도 되지만 띄워질 수도 있을 것이다.
- 따라서 단서의 양 끝과 그 사이사이에는 공간이 있을 것이다.
- 행/열에 단서와 최소한의 공간을 집어넣으면 남는 공간이 있을 것이다. 이것을 ‘가동범위(movable_padding)’라고 하자.
- 이 가동범위를 단서의 양 끝과 그 사이사이에 나누어 넣어야 할 것이다.

---

---

금지된 부분이 없고, 어떤 부분이 채워져있다고 가정하면,

- 그 칸이 어떤 단서의 일부인지 알아야 할 것이다.
    - 채워져 있던 칸의 개수에 따라 어떤 단서의 일부인지 추려낼 수 있을 것이다.
